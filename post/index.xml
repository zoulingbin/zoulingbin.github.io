<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on zoulingbin</title>
    <link>https://zoulingbin.github.io/post/</link>
    <description>Recent content in Posts on zoulingbin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Dec 2020 21:37:12 +0800</lastBuildDate>
    
	<atom:link href="https://zoulingbin.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>线程与进程</title>
      <link>https://zoulingbin.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Tue, 08 Dec 2020 21:37:12 +0800</pubDate>
      
      <guid>https://zoulingbin.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>进程 进程（Process）: 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。
线程 线程（thread）： 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
进程与线程的区别  线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见； 调度和切换：线程上下文切换比进程上下文切换要快得多； 进程开销大，线程开销小 线程天生的共享内存空间，线程间的通信更简单，避免了进程IPC引入新的复杂度。  进程间通信 管道通信 消息队列通信 共享内存通信 套接字通信 信号 </description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://zoulingbin.github.io/post/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 08 Dec 2020 21:30:38 +0800</pubDate>
      
      <guid>https://zoulingbin.github.io/post/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表不需要一块连续的内存空间，而是通过指针将一组零散的内存块串联起来使用。 单链表 链表有多种类型，最简单的是单链表，单链表是最原生的链表，其结构如图所示： 单链表中有两个节点比较特殊，分别是第一个结点和最后一个结点。我们通常把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。对单链表而言，理论上来说，插入和删除节点的时间复杂度是 O(1)，查询节点的时间复杂度是 O(n)。
循环链表 循环链表和单链表的区别是尾节点指向了头结点，从而首尾相连，可用于解决「约瑟夫环」问题。 双向链表 与单链表的区别是双向链表除了有一个指向下一个节点的指针外，还有一个用于指向上一个节点的指针，从而实现通过O(1)复杂度找到上一个节点。正是因为这个节点，使得双向链表在插入、删除节点时比单链表更高效，虽然我们前面已经提到单链表插入、删除时间复杂度已经是 O(1) 了，但是这没有考虑还只是针对插入、删除操作本身而言，以删除为例，删除某个节点后，需要将其前驱节点的指针指向被删除节点的下一个节点，这样，我们还需要获取其前驱节点，在单链表中获取前驱节点的时间复杂度是 O(n)，所以综合来看单链表的删除、插入操作时间复杂度也是 O(n)，而双向链表则不然，它有一个指针指向上一个节点，所以其插入和删除时间复杂度才是真正的 O(1)。
此外，对于有序链表而言，双向链表的查询效率显然也要高于单链表，不过更优的时间复杂度是靠更差的空间复杂度换取的，双向链表始终需要单链表的两倍空间，但是正如我们之前说的，在 Web 应用中，时间效率优先级更高，所以我们通常都是空间换时间来提高性能，Java 的 LinkedHashMap 底层就用到了双向链表。
双向循环链表 首尾通过指针连接起来。
php使用数组模拟实现单链表 class LinkedList { private $list = []; //获取链表指定位置的元素值，从0开始 public function get($index) { $value = null; while(current($this-&amp;gt;list)){ if(key($this-&amp;gt;list)==$index){ $value = current($this-&amp;gt;list); } next($this-&amp;gt;list); } reset($this-&amp;gt;list); return $value; } //在链表指定位置插入值，默认插到链表头部 public function add($value, $index=0) { array_splice($this-&amp;gt;list, $index, 0, $value); } // 从链表指定位置删除元素 public function remove($index) { array_splice($this-&amp;gt;list, $index, 1); } public function isEmpty() { return !</description>
    </item>
    
    <item>
      <title>闲谈tcp</title>
      <link>https://zoulingbin.github.io/post/%E9%97%B2%E8%B0%88tcp/</link>
      <pubDate>Tue, 08 Dec 2020 21:00:32 +0800</pubDate>
      
      <guid>https://zoulingbin.github.io/post/%E9%97%B2%E8%B0%88tcp/</guid>
      <description>TCP特点：   TCP是面向连接的传输层协议。在使用TCP协议之前必须先建立TCP连接，在传送数据完毕后，必须释放已经建立的tcp连接。
  TCP提供全双工通信。
  提供可靠交付。
  TCP 有拥塞控制，可以通过窗口控制对网络流量进行控制，避免网络拥塞。
  面向字节流。
  TCP连接： TCP报文首部：  源端口号：发送端端口号，占16bit。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。 目标端口号：接收端的端口号。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。 序列号：序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。 确认号：只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。 头部长度字段：TCP 所传输的数据部分应该从 TCP 包的哪个位置开始计算，也可以将其看作 TCP 包的长度，单位为4bit。它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。 窗口：明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口） CWR（Congestion Window Reduced）：与后面的ECE都是用于IP首部的ECN字段，为1时通知对方已将拥塞窗口缩小。 ECE（ECN-Echo）：置为1时通知通信对方，从对方到这边的网络有拥堵。 URG（Urgent Flag）：该位为1时，表示包中有需要紧急处理的数据。 ACK（Acknowledgement Flag）：该位为1时，确认应答的字段变为有效。 PSH（Push Flag）：该位为1时，表示需要将收到的数据立即传给上层应用协议，为0时则表示先不上传而是缓存起来。 RST（Reset Flag）：该位为1时，表示TCP连接中出现异常必须强制断开连接。 SYN（Synchronize Flag）：该位为1时，表示希望建立连接，并在序列号字段进行序列号初始值的设定。 FIN（Fin Flag）：该位为1时，表示今后不会再有数据发送，希望断开连接。 窗口大小：用于通知从相同 TCP 首部的确认应答号所指位置开始能够接收的数据大小。 校验值：TCP头部和TCP数据进行校验和计算，并由目标端进行验证。 紧急指针：只有在URG 控制位为1时有效，该字段数值表示本报文段中紧急数据的指针。  三次握手 客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。
 第一次握手:客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的,SYN=1,seq=x。 第二次握手:服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的，ACK=1,ack=x+1,SYN=1,seq=y。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。 第三次握手:客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的，seq=x+1,ACK=1,ack=y+1。  四次挥手  第一次：客户端请求断开FIN,seq=u。 第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v。 第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1。 第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1。  </description>
    </item>
    
  </channel>
</rss>